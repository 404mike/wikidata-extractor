{"wiki_id": "http://www.wikidata.org/entity/Q92686", "itemLabel": "David H. D. Warren", "itemDescription": "artificial intelligence researcher", "wikipedia_url": "https://en.wikipedia.org/wiki/David_H._D._Warren", "wikipedia_page": {"main": "David H. D. Warren is a computer scientist who worked primarily on logic programming and in particular the programming language Prolog in the 1970s and 1980s. Warren wrote the first compiler for Prolog, and the Warren Abstract Machine execution environment for Prolog is named after him.", "link_mentions": [{"page": "List of computer scientists", "response": ["* David H. D. Warren \u2013 AI, logic programming, Prolog, Warren Abstract Machine (WAM)"]}, {"page": "Prolog", "response": ["For efficiency, Prolog code is typically compiled to abstract machine code, often influenced by the register-based Warren Abstract Machine (WAM) instruction set.David H. D. Warren. \"An abstract Prolog instruction set\". Technical Note 309, SRI International, Menlo Park, CA, October 1983. Some implementations employ abstract interpretation to derive type and mode information of predicates at compile time, or compile to real machine code for high performance. Devising efficient implementation methods for Prolog code is a field of active research in the logic programming community, and various other execution methods are employed in some implementations. These include clause binarization and stack-based virtual machines.", "The name Prolog was chosen by Philippe Roussel as an abbreviation for  (French for programming in logic).  It was created around 1972 by Alain Colmerauer with Philippe Roussel, based on Robert Kowalski's procedural interpretation of Horn clauses.  It was motivated in part by the desire to reconcile the use of logic as a declarative knowledge representation language with the procedural representation of knowledge that was popular in North America in the late 1960s and early 1970s.  According to Robert Kowalski, the first Prolog system was developed in 1972 by Colmerauer and Phillipe Roussel. The first implementation of Prolog was an interpreter written in Fortran by Gerard Battani and Henri Meloni. David H. D. Warren took this interpreter to Edinburgh, and there implemented an alternative front-end, which came to define the \u201cEdinburgh Prolog\u201d syntax used by most modern implementations.  Warren also implemented the first compiler for Prolog, creating the influential DEC-10 Prolog in collaboration with Fernando Pereira.  Warren later generalised the ideas behind DEC-10 Prolog, to create the Warren Abstract Machine."]}, {"page": "Warren Abstract Machine", "response": ["In 1983, David H. D. Warren designed an abstract machine for the execution of Prolog consisting of a memory architecture and an instruction set. This design became known as the Warren Abstract Machine (WAM) and has become the de facto standard target for Prolog compilers."]}, {"page": "School of Informatics, University of Edinburgh", "response": ["*David H. D. Warren creator of the Warren Abstract Machine"]}, {"page": "Tail call", "response": ["Tail recursion modulo cons is a generalization of tail-recursion optimization introduced by David H. D. WarrenD. H. D. Warren, DAI Research Report 141, University of Edinburgh, 1980. in the context of compilation of Prolog, seen as an explicitly set once language. It was described (though not named) by Daniel P. Friedman and David S. Wise in 1974Daniel P. Friedman and David S. Wise, Technical Report TR19: Unwinding Structured Recursions into Iterations, Indiana University, Dec. 1974. as a LISP compilation technique. As the name suggests, it applies when the only operation left to perform after a recursive call is to prepend a known value in front of the list returned from it (or to perform a constant number of simple data-constructing operations, in general). This call would thus be a tail call save for (\"modulo\") the said cons operation. But prefixing a value at the start of a list on exit from a recursive call is the same as appending this value at the end of the growing list on entry into the recursive call, thus building the list as a side effect, as if in an implicit accumulator parameter. The following Prolog fragment illustrates the concept:\t"]}, {"page": "David Warren", "response": ["* David H. D. Warren, computer scientist"]}, {"page": "David H D Warren", "response": ["#REDIRECT David H. D. Warren "]}, {"page": "David H.D. Warren", "response": ["#REDIRECT David H. D. Warren "]}, {"page": "David HD Warren", "response": ["#REDIRECT David H. D. Warren "]}, {"page": "Cuthbert Hurd", "response": ["Hurd was a founder of Quintus Computer Systems in 1983 with William Kornfeld, Lawrence Byrd, Fernando Pereira and David H. D. Warren to commercialize a Prolog compiler."]}, {"page": "Association for Logic Programming", "response": ["* David H. D. Warren (UK)"]}]}}